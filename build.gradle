// ============================================================================
// Plugin Configuration
// ============================================================================
plugins {
    id 'base'
}

// ============================================================================
// Project Properties
// ============================================================================
ext {
    // Directory structure
    dataDir = file("data")
    serverDir = file("data/server")
    unpackedDir = file("data/unpacked")
    distDir = file("dist")
    staticDir = file("packages/ui-frontdoor/public")
    
    // Assets
    serverAssetsDir = file("data/assets")       // Extracted vanilla assets from server
    
    // Server files
    serverJar = file("data/server/Server/HytaleServer.jar")
    assetsZip = file("data/server/Assets.zip")
    modsDir = file("data/server/Server/mods")
    
    // Docker
    composeFile = file("compose.yml")
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Execute a shell command with optional error handling and output capture
 */
def runCommand(List<String> command, boolean ignoreExitValue = false, File workingDir = null, boolean quiet = false) {
    def processBuilder = new ProcessBuilder(command)
    if (workingDir != null) {
        processBuilder.directory(workingDir)
    }
    processBuilder.redirectErrorStream(true)

    def process = processBuilder.start()
    def output = new StringBuilder()
    process.inputStream.newReader().eachLine { line ->
        output.append(line).append('\n')
        if (!quiet) {
            println(line)
        }
    }

    int exitCode = process.waitFor()
    if (exitCode != 0 && !ignoreExitValue) {
        throw new IllegalStateException("Command failed (${command.join(' ')}), exit code ${exitCode}\n${output}")
    }

    return [exitCode: exitCode, output: output.toString()]
}

/**
 * Ensure directory exists with proper ownership (skipped in CI)
 */
def ensureDirectoryOwned(File dir) {
    if (!dir.exists()) {
        if (!dir.mkdirs()) {
            throw new IllegalStateException("Failed to create directory ${dir}")
        }
    }
    if (!System.getenv("CI")) {
        runCommand(["chown", "1000:1000", dir.absolutePath])
    }
}

/**
 * Wait for a file to appear with timeout
 */
def waitForFile(File target, int timeoutSeconds, int intervalSeconds) {
    long deadline = System.currentTimeMillis() + (timeoutSeconds * 1000L)
    while (System.currentTimeMillis() < deadline) {
        if (target.exists()) {
            return
        }
        sleep(intervalSeconds * 1000L)
    }
    throw new IllegalStateException("Timed out waiting for ${target}")
}

// ============================================================================
// Setup Tasks
// Tasks for initial project setup: directories, server JAR, assets, and API
// ============================================================================

tasks.register("setup") {
    group = "setup"
    description = "Prepare local data, assets, and unpacked API"
    dependsOn "ensureDirectories", "ensureServerJar", "unpackAssets", "unpackJar"
}

tasks.register("ensureDirectories") {
    group = "setup"
    description = "Ensure data directories exist with uid:gid 1000:1000"
    def dirs = [serverDir, serverAssetsDir, unpackedDir]
    def isCI = System.getenv("CI")
    doLast {
        dirs.each { dir ->
            if (!dir.exists()) {
                if (!dir.mkdirs()) {
                    throw new IllegalStateException("Failed to create directory ${dir}")
                }
            }
            if (!isCI) {
                def proc = new ProcessBuilder(["chown", "1000:1000", dir.absolutePath])
                    .redirectErrorStream(true)
                    .start()
                def output = new StringBuilder()
                proc.inputStream.newReader().eachLine { output.append(it).append('\\n') }
                int exitCode = proc.waitFor()
                if (exitCode != 0) {
                    throw new IllegalStateException("chown failed with exit code ${exitCode}\\n${output}")
                }
            }
        }
    }
}

tasks.register("ensureModsDir") {
    group = "setup"
    description = "Ensure server mods directory exists with uid:gid 1000:1000"
    dependsOn "ensureDirectories"
    doLast {
        ensureDirectoryOwned(modsDir)
    }
}

tasks.register("ensureServerJar") {
    group = "setup"
    description = "Start docker compose to produce HytaleServer.jar when missing"
    dependsOn "ensureDirectories"
    onlyIf { !serverJar.exists() }
    doLast {
        if (System.getenv("CI")) {
            def downloadUrl = System.getenv("HYTALE_SERVER_JAR_DOWNLOAD_URL")
            if (!downloadUrl) {
                throw new IllegalStateException(
                    "HytaleServer.jar not found in CI. " +
                    "Set HYTALE_SERVER_JAR_DOWNLOAD_URL environment variable to download the jar. " +
                    "See docs/CI_REQUIREMENT.md for details."
                )
            }
            logger.lifecycle("Downloading HytaleServer.jar from URL...")
            serverJar.parentFile.mkdirs()
            
            def tempFile = new File(serverJar.parentFile, "HytaleServer.jar.tmp")
            tempFile.delete() // Clean up any previous failed download
            
            // Use curl with follow redirects and progress for large files
            def result = runCommand(["curl", "-L", "-o", tempFile.absolutePath, "--fail", "--progress-bar", downloadUrl], true)
            
            if (result.exitCode != 0) {
                tempFile.delete()
                throw new IllegalStateException(
                    "Failed to download HytaleServer.jar (curl exit code: ${result.exitCode}). " +
                    "Verify HYTALE_SERVER_JAR_DOWNLOAD_URL is a valid direct download link."
                )
            }
            
            // Verify the downloaded file exists and has reasonable size
            if (!tempFile.exists() || tempFile.length() < 1024 * 1024) {
                def actualSize = tempFile.exists() ? tempFile.length() : 0
                def preview = ""
                if (tempFile.exists() && tempFile.length() > 0) {
                    def content = tempFile.text.take(500)
                    preview = "\n\nFirst 500 chars of downloaded file:\n${content}"
                }
                tempFile.delete()
                throw new IllegalStateException(
                    "Downloaded HytaleServer.jar is missing or too small (${actualSize} bytes). " +
                    "Expected at least 1MB (actual jar is ~80MB). " +
                    "Verify the download URL provides a direct file download, not an HTML page or sharing link." +
                    preview
                )
            }
            
            // Verify the downloaded file is a valid JAR/ZIP
            def isValidJar = false
            def jarError = ""
            try {
                def zipFile = new java.util.zip.ZipFile(tempFile)
                try {
                    // Check if it has at least one entry (valid ZIP structure)
                    isValidJar = zipFile.entries().hasMoreElements()
                } finally {
                    zipFile.close()
                }
            } catch (Exception e) {
                jarError = e.message
            }
            
            if (!isValidJar) {
                def preview = ""
                if (tempFile.length() > 0) {
                    def content = tempFile.text.take(500)
                    preview = "\n\nFirst 500 chars of downloaded file:\n${content}"
                }
                tempFile.delete()
                throw new IllegalStateException(
                    "Downloaded file is not a valid JAR/ZIP file. " +
                    "Size: ${tempFile.length()} bytes. " +
                    "Error: ${jarError}. " +
                    "Verify HYTALE_SERVER_JAR_DOWNLOAD_URL is a direct download link to the JAR file." +
                    preview
                )
            }
            
            // Move temp file to final location
            serverJar.delete()
            tempFile.renameTo(serverJar)
            
            logger.lifecycle("Downloaded ${serverJar.name} successfully (${String.format('%.2f', serverJar.length() / (1024 * 1024))} MB)")
            return
        }
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        logger.lifecycle("Launching docker compose to fetch HytaleServer.jar...")
        logger.lifecycle("Container will require OAuth login - follow the logs below:")
        runCommand(["docker", "compose", "-f", composeFile.absolutePath, "up", "-d"])
        
        // Follow logs and wait for boot message
        def logsProcess = new ProcessBuilder("docker", "compose", "-f", composeFile.absolutePath, "logs", "-f")
            .redirectErrorStream(true)
            .start()
        
        def serverBooted = false
        def logThread = Thread.start {
            logsProcess.inputStream.eachLine { line ->
                println(line)
                if (line.contains("Hytale Server Booted!")) {
                    serverBooted = true
                }
            }
        }
        
        try {
            // Wait for boot message with timeout
            long deadline = System.currentTimeMillis() + (300 * 1000L)
            while (!serverBooted && System.currentTimeMillis() < deadline) {
                sleep(2000)
            }
            
            if (!serverBooted) {
                throw new IllegalStateException("Timed out waiting for 'Hytale Server Booted!' message")
            }
            
            logger.lifecycle("Server booted successfully!")
            
            // Wait a bit more to ensure files are flushed
            sleep(2000)
            
            if (!serverJar.exists()) {
                throw new IllegalStateException("Server booted but ${serverJar} not found")
            }
            
            logger.lifecycle("Found ${serverJar}")
        } finally {
            logsProcess.destroy()
            logThread.join(1000)
            runCommand(["docker", "compose", "-f", composeFile.absolutePath, "down"])
        }
    }
}

tasks.register("unpackAssets") {
    group = "setup"
    description = "Unzip Assets.zip into data/assets"
    dependsOn "ensureDirectories"
    mustRunAfter "ensureServerJar"
    onlyIf { assetsZip.exists() }
    doLast {
        ant.unzip(src: assetsZip, dest: serverAssetsDir, overwrite: true)
    }
}



// ============================================================================
// Build Tasks
// Tasks for building and packaging mod artifacts
// ============================================================================

apply from: file("$rootDir/gradle/shared/dev-feed.gradle")

tasks.register("validateAssetConflicts") {
    group = "validation"
    description = "Validate that custom assets don't overwrite core game assets (files only, folders are OK)"
    
    doLast {
        def dataAssetsDir = file("data/assets")
        def pluginAssetsDirs = subprojects.findAll { it.path.startsWith(":plugins:") }
            .collect { it.file("src/main/resources") }
            .findAll { it.exists() }
        
        // Files that are allowed to override (extensions, fallbacks, per-plugin metadata)
        def isAllowedOverride = { String relativePath ->
            return (
                relativePath == "Server/Languages/en-US/server.lang" ||  // Language extensions
                relativePath == "manifest.json" ||                        // Plugin manifests
                relativePath.startsWith("Common/UI/Custom/") ||           // Custom UI
                relativePath.startsWith("UI/Custom/") ||                  // Custom UI (alt root)
                relativePath.startsWith("Custom/")                        // Custom root fallback
            )
        }
        
        def conflicts = []
        
        pluginAssetsDirs.each { pluginDir ->
            pluginDir.eachFileRecurse { customFile ->
                if (customFile.isFile()) {
                    // Calculate relative path from plugin assets root
                    def relativePath = customFile.absolutePath - pluginDir.absolutePath - File.separator
                    def baseGameFile = new File(dataAssetsDir, relativePath)
                    
                    if (baseGameFile.exists() && baseGameFile.isFile() && !isAllowedOverride(relativePath)) {
                        conflicts.add([
                            custom: customFile.absolutePath,
                            baseGame: baseGameFile.absolutePath,
                            relativePath: relativePath
                        ])
                    }
                }
            }
        }
        
        if (conflicts) {
            def report = new StringBuilder()
            report.append("\n❌ ASSET CONFLICT ERROR: Custom assets are overwriting core game files!\n\n")
            report.append("The following files in plugins/*/src/main/resources/ conflict with data/assets/:\n\n")
            conflicts.each { conflict ->
                report.append("  ❌ ${conflict.relativePath}\n")
                report.append("     Custom:   ${conflict.custom}\n")
                report.append("     BaseGame: ${conflict.baseGame}\n\n")
            }
            report.append("SOLUTION: Move conflicting files to use a custom namespace (e.g., Vex/ instead of Common/)\n")
            report.append("See .github/instructions/ui.instructions.md for naming guidelines.\n")
            
            throw new GradleException(report.toString())
        } else {
            logger.lifecycle("✅ Asset validation passed - no conflicts with core game files")
        }
    }
}


tasks.register("exportPermissions") {
    group = "build"
    description = "Export plugin permissions to static/permissions.json"
    doLast {
        def outputFile = file("static/permissions.json")
        outputFile.parentFile.mkdirs()

        def permissions = []
        def permissionDescriptions = [
            "vex.score.view": "View the Vex leaderboard via /vex score.",
            "vex.score.edit": "Edit Vex score metrics via /vex score edit <player> <metric> <value>.",
            "vex.ui.list": "List Vex UI templates via /vex ui list.",
            "vex.ui.show": "Show a Vex UI template via /vex ui show <id>.",
            "vex.ui.reload": "Reload Vex UI templates via /vex ui reload.",
            "vex.removeinstances": "Remove all Vex dungeon instance data via /vex removeinstances.",
            "vex.purge": "Purge Vex instance data and delete dungeons.json via /vex purge."
        ]
        def permissionCommands = [
            "vex.score.view": "/vex score",
            "vex.score.edit": "/vex score edit <player> <metric> <value>",
            "vex.ui.list": "/vex ui list",
            "vex.ui.show": "/vex ui show <id>",
            "vex.ui.reload": "/vex ui reload",
            "vex.removeinstances": "/vex removeinstances",
            "vex.purge": "/vex purge"
        ]
        def pluginProjects = subprojects.findAll { it.path.startsWith(":plugins:") }
        pluginProjects.each { projectRef ->
            def pluginProps = projectRef.file("src/main/resources/plugin.properties")
            def pluginName = projectRef.name
            if (pluginProps.exists()) {
                pluginProps.readLines().each { line ->
                    if (line.startsWith("plugin-name=")) {
                        pluginName = line.substring("plugin-name=".length()).trim()
                    }
                }
            }

            def javaDir = projectRef.file("src/main/java")
            if (!javaDir.exists()) {
                return
            }

            projectRef.fileTree(javaDir).matching { include "**/*.java" }.each { javaFile ->
                def text = javaFile.getText("UTF-8")
                def permMatcher = (text =~ /PERMISSION_([A-Z0-9_]+)\s*=\s*\"([^\"]+)\"/)
                if (!permMatcher.find()) {
                    return
                }
                permMatcher.reset()
                def descMatcher = (text =~ /super\\(\"[^\"]+\"\\s*,\\s*\"([^\"]+)\"\\)/)
                def baseDesc = descMatcher.find() ? descMatcher.group(1) : null

                def permList = []
                permMatcher.each { match ->
                    permList << [name: match[1], value: match[2]]
                }

                permList.each { perm ->
                    def explicitDesc = permissionDescriptions.get(perm.value)
                    def desc = explicitDesc ?: baseDesc ?: "Permission required"
                    if (!explicitDesc && permList.size() > 1 && baseDesc != null) {
                        def suffix = perm.name.toLowerCase().replaceAll("_", " ")
                        desc = "${baseDesc} (${suffix})"
                    }
                    permissions << [
                        plugin      : pluginName,
                        permission  : perm.value,
                        description : desc,
                        command     : permissionCommands.get(perm.value)
                    ]
                }
            }
        }

        def json = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(permissions))
        outputFile.text = json + System.lineSeparator()
        logger.lifecycle("Wrote permissions to ${outputFile}")
    }
}


tasks.register("cleanDist") {
    group = "build"
    description = "Remove dist directory"
    doLast {
        delete distDir
    }
}

tasks.named("clean") {
    dependsOn "cleanDist"
}

def resolveJarProjects = {
    subprojects.findAll { projectRef ->
        (projectRef.path.startsWith(":plugins:") || projectRef.path.startsWith(":shared:")) &&
            projectRef.path != ":plugins:forwarder" &&
            projectRef.path != ":shared:utilities" &&
            (projectRef.plugins.hasPlugin("java") || projectRef.plugins.hasPlugin("java-library"))
    }
}

tasks.register("copyAllProjectJarsToDist", Copy) {
    group = "build"
    description = "Copy all plugin/shared jars into dist (excluding forwarder)"
    into(distDir)
    doFirst {
        distDir.mkdirs()
    }
}

tasks.register("copyPluginJarToDist", Copy) {
    group = "build"
    description = "Copy plugin jar into dist"
    dependsOn ":plugins:roguelike:jar"
    from { project(":plugins:roguelike").tasks.named("jar").flatMap { it.archiveFile } }
    into(distDir)
    doFirst {
        distDir.mkdirs()
    }
}

def pluginProjects = subprojects.findAll { 
    it.path.startsWith(":plugins:") && it.path != ":plugins:forwarder"
}

tasks.register("copyAllPluginJarsToDist", Copy) {
    group = "build"
    description = "Copy all plugin jars into dist (excluding forwarder)"
    dependsOn(pluginProjects.collect { it.tasks.named("jar") })
    pluginProjects.each { projectRef ->
        from(projectRef.tasks.named("jar").flatMap { it.archiveFile })
    }

    into(distDir)
    doFirst {
        distDir.mkdirs()
    }
}

tasks.register("copyStaticToDist", Copy) {
    group = "build"
    description = "Copy static site into dist/static"
    dependsOn "updateDevFeed"
    from(staticDir)
    into(new File(distDir, "static"))
    exclude "**/.DS_Store"
    doFirst {
        distDir.mkdirs()
    }
}


tasks.register("copyEngineJarToDist") {
    group = "build"
    description = "Copy engine jar into dist (legacy wrapper)"
    dependsOn "copyAllPluginJarsToDist"
}

// ============================================================================
// Post-Build Docker Compose Restart
// ============================================================================
gradle.buildFinished { result ->
    if (System.getenv("CI")) {
        logger.lifecycle("CI detected; skipping docker compose restart.")
        return
    }
    if (!composeFile.exists()) {
        logger.lifecycle("compose.yml not found; skipping docker compose restart.")
        return
    }

    def psResult = runCommand(
        ["docker", "compose", "-f", composeFile.absolutePath, "ps", "-q"],
        true,
        null,
        true
    )
    def running = psResult.output?.trim()
    if (running) {
        logger.lifecycle("Docker compose is running; restarting services...")
        runCommand(["docker", "compose", "-f", composeFile.absolutePath, "restart"], true)
    } else {
        logger.lifecycle("Docker compose is not running; no restart needed.")
    }
}

// ============================================================================
// Distribution Tasks
// Tasks for installing built artifacts to server mods directory
// ============================================================================

tasks.register("installToServerMods") {
    group = "distribution"
    description = "Copy jars into data/server/Server/mods"
    // TEMP: Only install selected jars during build
    // dependsOn "ensureModsDir", "assetsZip", "friendsAssetsZip", "copyAllPluginJarsToDist"
    dependsOn "ensureModsDir", "copyAllProjectJarsToDist"
    doFirst { }
    doLast { }
}

gradle.projectsEvaluated {
    def jarProjects = resolveJarProjects()

    tasks.named("copyAllProjectJarsToDist").configure {
        dependsOn(jarProjects.collect { it.tasks.named("jar") })
        jarProjects.each { projectRef ->
            from(projectRef.tasks.named("jar").flatMap { it.archiveFile })
        }
    }

    tasks.named("installToServerMods").configure {
        doFirst {
            def pluginJarNames = jarProjects.collect { projectRef ->
                projectRef.tasks.named("jar").get().archiveFileName.get()
            }
            pluginJarNames.each { jarName ->
                delete new File(modsDir, jarName)
            }
        }
        doLast {
            copy {
                jarProjects.each { projectRef ->
                    from(projectRef.tasks.named("jar").flatMap { it.archiveFile })
                }
                // from(tasks.named("assetsZip").flatMap { it.archiveFile })
                // from(tasks.named("friendsAssetsZip").flatMap { it.archiveFile })
                into(modsDir)
                duplicatesStrategy = DuplicatesStrategy.INCLUDE
            }
        }
    }
}

// ============================================================================
// Utility Tasks
// ============================================================================

tasks.register("unpackJar") {
    group = "setup"
    description = "Unpack data/server/Server/HytaleServer.jar into data/unpacked"
    dependsOn "ensureDirectories", "ensureServerJar"
    onlyIf { !unpackedDir.exists() || unpackedDir.listFiles()?.length == 0 }
    doLast {
        if (unpackedDir.exists()) {
            unpackedDir.deleteDir()
        }
        copy {
            from(zipTree(serverJar))
            into(unpackedDir)
        }
        logger.lifecycle("Unpacked ${serverJar} into ${unpackedDir}")
    }
}

// ============================================================================
// Application Lifecycle Tasks
// Tasks for running and managing the Hytale server via Docker
// ============================================================================

tasks.register("composeDown") {
    group = "application"
    description = "Stop docker compose stack if running"
    doLast {
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        def psOutput = new ByteArrayOutputStream()
        def psResult = runCommand(["docker", "compose", "-f", composeFile.absolutePath, "ps", "-q"], true, null, true)
        psOutput.write(psResult.output.getBytes())
        if (psResult.output.toString().trim()) {
            logger.lifecycle("Stopping existing compose stack before rebuild...")
            runCommand(["docker", "compose", "-f", composeFile.absolutePath, "down"])
        } else {
            logger.lifecycle("No running compose stack detected; nothing to stop.")
        }
    }
}

tasks.register("start") {
    group = "application"
    description = "Run build then start docker compose in foreground"
    dependsOn "composeDown", "build"
    doLast {
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        logger.lifecycle("Starting docker compose in foreground (logs attached)...")
        runCommand(["docker", "compose", "-f", composeFile.absolutePath, "up"])
    }
}

// ============================================================================
// Gradle Lifecycle Customization
// Modify standard Gradle build lifecycle tasks
// ============================================================================

tasks.register("validateUi", JavaExec) {
    group = "validation"
    description = "Validate UI syntax in all .ui files in plugins/"
    classpath = project(":tools:ui-validator").sourceSets.main.runtimeClasspath
    mainClass = "MBRound18.hytale.tools.UiValidator"
    args file("plugins").absolutePath,
        "--import-root", file("plugins").absolutePath,
        "--import-root", file("data/assets").absolutePath,
        "--asset-root", file("plugins").absolutePath,
        "--asset-root", file("data/assets").absolutePath
    
    dependsOn ":tools:ui-validator:classes"
}

tasks.register("test") {
    group = "validation"
    description = "Run all validation tasks"
    dependsOn "validateUi", ":tools:ui-validator:test"
}

tasks.named("assemble") {
    dependsOn "copyAllProjectJarsToDist", "validateUi"
}

tasks.named("build") {
    dependsOn "exportPermissions",
        "copyStaticToDist",
        "updateDevFeed",
        "validateDevFeed",
        "copyAllProjectJarsToDist",
        "installToServerMods"
    mustRunAfter "composeDown"
}

// ============================================================================
// Error Reporting Hook
// Provide helpful error context on build failure
// ============================================================================
