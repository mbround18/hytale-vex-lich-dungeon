// ============================================================================
// Plugin Configuration
// ============================================================================
plugins {
    id 'base'
}

// ============================================================================
// Project Properties
// ============================================================================
ext {
    // Directory structure
    dataDir = file("data")
    serverDir = file("data/server")
    unpackedDir = file("data/unpacked")
    distDir = file("dist")
    
    // Assets
    userAssetsDir = file("plugins/roguelike/assets") // User-authored assets for packing
    friendsAssetsDir = file("plugins/friends/assets")
    serverAssetsDir = file("data/assets")       // Extracted vanilla assets from server
    
    // Server files
    serverJar = file("data/server/Server/HytaleServer.jar")
    assetsZip = file("data/server/Assets.zip")
    modsDir = file("data/server/Server/mods")
    
    // Docker
    composeFile = file("compose.yml")
}

// ============================================================================
// Helper Functions
// ============================================================================

/**
 * Execute a shell command with optional error handling and output capture
 */
def runCommand(List<String> command, boolean ignoreExitValue = false, File workingDir = null, boolean quiet = false) {
    def processBuilder = new ProcessBuilder(command)
    if (workingDir != null) {
        processBuilder.directory(workingDir)
    }
    processBuilder.redirectErrorStream(true)

    def process = processBuilder.start()
    def output = new StringBuilder()
    process.inputStream.newReader().eachLine { line ->
        output.append(line).append('\n')
        if (!quiet) {
            println(line)
        }
    }

    int exitCode = process.waitFor()
    if (exitCode != 0 && !ignoreExitValue) {
        throw new IllegalStateException("Command failed (${command.join(' ')}), exit code ${exitCode}\n${output}")
    }

    return [exitCode: exitCode, output: output.toString()]
}

/**
 * Ensure directory exists with proper ownership (skipped in CI)
 */
def ensureDirectoryOwned(File dir) {
    if (!dir.exists()) {
        if (!dir.mkdirs()) {
            throw new IllegalStateException("Failed to create directory ${dir}")
        }
    }
    if (!System.getenv("CI")) {
        runCommand(["chown", "1000:1000", dir.absolutePath])
    }
}

/**
 * Wait for a file to appear with timeout
 */
def waitForFile(File target, int timeoutSeconds, int intervalSeconds) {
    long deadline = System.currentTimeMillis() + (timeoutSeconds * 1000L)
    while (System.currentTimeMillis() < deadline) {
        if (target.exists()) {
            return
        }
        sleep(intervalSeconds * 1000L)
    }
    throw new IllegalStateException("Timed out waiting for ${target}")
}

// ============================================================================
// Setup Tasks
// Tasks for initial project setup: directories, server JAR, assets, and API
// ============================================================================

tasks.register("setup") {
    group = "setup"
    description = "Prepare local data, assets, and unpacked API"
    dependsOn "ensureDirectories", "ensureServerJar", "unpackAssets", "unpackJar"
}

tasks.register("ensureDirectories") {
    group = "setup"
    description = "Ensure data directories exist with uid:gid 1000:1000"
    def dirs = [serverDir, userAssetsDir, friendsAssetsDir, serverAssetsDir, unpackedDir]
    def isCI = System.getenv("CI")
    doLast {
        dirs.each { dir ->
            if (!dir.exists()) {
                if (!dir.mkdirs()) {
                    throw new IllegalStateException("Failed to create directory ${dir}")
                }
            }
            if (!isCI) {
                def proc = new ProcessBuilder(["chown", "1000:1000", dir.absolutePath])
                    .redirectErrorStream(true)
                    .start()
                def output = new StringBuilder()
                proc.inputStream.newReader().eachLine { output.append(it).append('\\n') }
                int exitCode = proc.waitFor()
                if (exitCode != 0) {
                    throw new IllegalStateException("chown failed with exit code ${exitCode}\\n${output}")
                }
            }
        }
    }
}

tasks.register("ensureModsDir") {
    group = "setup"
    description = "Ensure server mods directory exists with uid:gid 1000:1000"
    dependsOn "ensureDirectories"
    doLast {
        ensureDirectoryOwned(modsDir)
    }
}

tasks.register("ensureServerJar") {
    group = "setup"
    description = "Start docker compose to produce HytaleServer.jar when missing"
    dependsOn "ensureDirectories"
    onlyIf { !serverJar.exists() }
    doLast {
        if (System.getenv("CI")) {
            def downloadUrl = System.getenv("HYTALE_SERVER_JAR_DOWNLOAD_URL")
            if (!downloadUrl) {
                throw new IllegalStateException(
                    "HytaleServer.jar not found in CI. " +
                    "Set HYTALE_SERVER_JAR_DOWNLOAD_URL environment variable to download the jar. " +
                    "See docs/CI_REQUIREMENT.md for details."
                )
            }
            logger.lifecycle("Downloading HytaleServer.jar from URL...")
            serverJar.parentFile.mkdirs()
            
            def tempFile = new File(serverJar.parentFile, "HytaleServer.jar.tmp")
            tempFile.delete() // Clean up any previous failed download
            
            // Use curl with follow redirects and progress for large files
            def result = runCommand(["curl", "-L", "-o", tempFile.absolutePath, "--fail", "--progress-bar", downloadUrl], true)
            
            if (result.exitCode != 0) {
                tempFile.delete()
                throw new IllegalStateException(
                    "Failed to download HytaleServer.jar (curl exit code: ${result.exitCode}). " +
                    "Verify HYTALE_SERVER_JAR_DOWNLOAD_URL is a valid direct download link."
                )
            }
            
            // Verify the downloaded file exists and has reasonable size
            if (!tempFile.exists() || tempFile.length() < 1024 * 1024) {
                def actualSize = tempFile.exists() ? tempFile.length() : 0
                def preview = ""
                if (tempFile.exists() && tempFile.length() > 0) {
                    def content = tempFile.text.take(500)
                    preview = "\n\nFirst 500 chars of downloaded file:\n${content}"
                }
                tempFile.delete()
                throw new IllegalStateException(
                    "Downloaded HytaleServer.jar is missing or too small (${actualSize} bytes). " +
                    "Expected at least 1MB (actual jar is ~80MB). " +
                    "Verify the download URL provides a direct file download, not an HTML page or sharing link." +
                    preview
                )
            }
            
            // Verify the downloaded file is a valid JAR/ZIP
            def isValidJar = false
            def jarError = ""
            try {
                def zipFile = new java.util.zip.ZipFile(tempFile)
                try {
                    // Check if it has at least one entry (valid ZIP structure)
                    isValidJar = zipFile.entries().hasMoreElements()
                } finally {
                    zipFile.close()
                }
            } catch (Exception e) {
                jarError = e.message
            }
            
            if (!isValidJar) {
                def preview = ""
                if (tempFile.length() > 0) {
                    def content = tempFile.text.take(500)
                    preview = "\n\nFirst 500 chars of downloaded file:\n${content}"
                }
                tempFile.delete()
                throw new IllegalStateException(
                    "Downloaded file is not a valid JAR/ZIP file. " +
                    "Size: ${tempFile.length()} bytes. " +
                    "Error: ${jarError}. " +
                    "Verify HYTALE_SERVER_JAR_DOWNLOAD_URL is a direct download link to the JAR file." +
                    preview
                )
            }
            
            // Move temp file to final location
            serverJar.delete()
            tempFile.renameTo(serverJar)
            
            logger.lifecycle("Downloaded ${serverJar.name} successfully (${String.format('%.2f', serverJar.length() / (1024 * 1024))} MB)")
            return
        }
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        logger.lifecycle("Launching docker compose to fetch HytaleServer.jar...")
        logger.lifecycle("Container will require OAuth login - follow the logs below:")
        runCommand(["docker", "compose", "-f", composeFile.absolutePath, "up", "-d"])
        
        // Follow logs and wait for boot message
        def logsProcess = new ProcessBuilder("docker", "compose", "-f", composeFile.absolutePath, "logs", "-f")
            .redirectErrorStream(true)
            .start()
        
        def serverBooted = false
        def logThread = Thread.start {
            logsProcess.inputStream.eachLine { line ->
                println(line)
                if (line.contains("Hytale Server Booted!")) {
                    serverBooted = true
                }
            }
        }
        
        try {
            // Wait for boot message with timeout
            long deadline = System.currentTimeMillis() + (300 * 1000L)
            while (!serverBooted && System.currentTimeMillis() < deadline) {
                sleep(2000)
            }
            
            if (!serverBooted) {
                throw new IllegalStateException("Timed out waiting for 'Hytale Server Booted!' message")
            }
            
            logger.lifecycle("Server booted successfully!")
            
            // Wait a bit more to ensure files are flushed
            sleep(2000)
            
            if (!serverJar.exists()) {
                throw new IllegalStateException("Server booted but ${serverJar} not found")
            }
            
            logger.lifecycle("Found ${serverJar}")
        } finally {
            logsProcess.destroy()
            logThread.join(1000)
            runCommand(["docker", "compose", "-f", composeFile.absolutePath, "down"])
        }
    }
}

tasks.register("unpackAssets") {
    group = "setup"
    description = "Unzip Assets.zip into data/assets"
    dependsOn "ensureDirectories"
    mustRunAfter "ensureServerJar"
    onlyIf { assetsZip.exists() }
    doLast {
        ant.unzip(src: assetsZip, dest: serverAssetsDir, overwrite: true)
    }
}



// ============================================================================
// Build Tasks
// Tasks for building and packaging mod artifacts
// ============================================================================

tasks.register("processAssetsManifest") {
    group = "build"
    description = "Process plugins/roguelike/assets/manifest.json with version and authors"
    
    def inputManifest = file("plugins/roguelike/assets/manifest.json")
    def outputManifest = file("$buildDir/processed-assets/manifest.json")
    
    inputs.file(inputManifest)
    outputs.file(outputManifest)
    
    doLast {
        outputManifest.parentFile.mkdirs()
        
        def manifestContent = inputManifest.text
        def pluginVersion = project(":plugins:roguelike").version
        
        // Get authors from git (same logic as plugin)
        def authorsJson = """[
  {
    "Name": "Example Dev",
    "Email": "dev@example.com",
    "Url": ""
  }
]"""
        
        try {
            def gitProcess = new ProcessBuilder(["git", "log", "--format=%an|%ae"]).redirectErrorStream(true).start()
            def gitLog = new StringBuilder()
            gitProcess.inputStream.newReader().eachLine { line ->
                gitLog.append(line).append('\n')
            }
            int gitExit = gitProcess.waitFor()
            def authors = gitLog.toString().readLines()
                .collect { it.split("\\|") }
                .findAll { it.size() == 2 }
                .collect { [name: it[0].trim(), email: it[1].trim()] }
                .unique { [it.name, it.email] }
            
            if (gitExit == 0 && !authors.isEmpty()) {
                def entries = authors.collect { author ->
                    """  {
    "Name": "${author.name}",
    "Email": "${author.email}",
    "Url": ""
  }"""
                }.join(',\n')
                authorsJson = "[\n${entries}\n]"
            }

        } catch (Exception e) {
            logger.warn("Failed to extract git authors for assets manifest: ${e.message}")
        }
        
        // Replace version
        manifestContent = manifestContent.replaceAll('"Version"\\s*:\\s*"[^"]*"', "\"Version\": \"${pluginVersion}\"")
        
        // Replace authors array
        manifestContent = manifestContent.replaceAll(
            '"Authors"\\s*:\\s*\\[[^\\]]*\\]',
            "\"Authors\": ${authorsJson}"
        )
        
        outputManifest.text = manifestContent
        logger.lifecycle("Processed assets manifest.json with version ${pluginVersion}")
    }
}

tasks.register("processFriendsAssetsManifest") {
    group = "build"
    description = "Process plugins/friends/assets/manifest.json with version and authors"

    def inputManifest = file("plugins/friends/assets/manifest.json")
    def outputManifest = file("$buildDir/processed-friends-assets/manifest.json")

    inputs.file(inputManifest)
    outputs.file(outputManifest)

    doLast {
        outputManifest.parentFile.mkdirs()

        def manifestContent = inputManifest.text
        def pluginVersion = project(":plugins:friends").version

        def authorsJson = """[
  {
    "Name": "Example Dev",
    "Email": "dev@example.com",
    "Url": ""
  }
]"""

        try {
            def gitProcess = new ProcessBuilder(["git", "log", "--format=%an|%ae"]).redirectErrorStream(true).start()
            def gitLog = new StringBuilder()
            gitProcess.inputStream.newReader().eachLine { line ->
                gitLog.append(line).append('\n')
            }
            int gitExit = gitProcess.waitFor()
            def authors = gitLog.toString().readLines()
                .collect { it.split("\\|") }
                .findAll { it.size() == 2 }
                .collect { [name: it[0].trim(), email: it[1].trim()] }
                .unique { [it.name, it.email] }

            if (gitExit == 0 && !authors.isEmpty()) {
                def entries = authors.collect { author ->
                    """  {
    "Name": "${author.name}",
    "Email": "${author.email}",
    "Url": ""
  }"""
                }.join(',\n')
                authorsJson = "[\n${entries}\n]"
            }
        } catch (Exception e) {
            logger.warn("Failed to extract git authors for friends assets manifest: ${e.message}")
        }

        manifestContent = manifestContent.replaceAll('"Version"\\s*:\\s*"[^"]*"', "\"Version\": \"${pluginVersion}\"")
        manifestContent = manifestContent.replaceAll(
            '"Authors"\\s*:\\s*\\[[^\\]]*\\]',
            "\"Authors\": ${authorsJson}"
        )

        outputManifest.text = manifestContent
        logger.lifecycle("Processed friends assets manifest.json with version ${pluginVersion}")
    }
}

tasks.register("validateAssetConflicts") {
    group = "validation"
    description = "Validate that custom assets don't overwrite core game assets (files only, folders are OK)"
    
    doLast {
        def dataAssetsDir = file("data/assets")
        def pluginAssetsDirs = [
            file("plugins/roguelike/assets"),
            file("plugins/friends/assets"),
            file("plugins/forwarder/assets")
        ].findAll { it.exists() }
        
        // Files that are allowed to override (extensions, fallbacks, per-plugin metadata)
        def isAllowedOverride = { String relativePath ->
            return (
                relativePath == "Server/Languages/en-US/server.lang" ||  // Language extensions
                relativePath == "manifest.json" ||                        // Plugin manifests
                relativePath.startsWith("Common/UI/Custom/Vex/") ||      // Vex namespace
                relativePath.startsWith("Common/UI/Custom/Hud/") ||      // Hud namespace
                relativePath.startsWith("Common/UI/Custom/Pages/") ||    // Custom UI Pages
                relativePath.startsWith("Custom/")                        // Custom root fallback
            )
        }
        
        def conflicts = []
        
        pluginAssetsDirs.each { pluginDir ->
            pluginDir.eachFileRecurse { customFile ->
                if (customFile.isFile()) {
                    // Calculate relative path from plugin assets root
                    def relativePath = customFile.absolutePath - pluginDir.absolutePath - File.separator
                    def baseGameFile = new File(dataAssetsDir, relativePath)
                    
                    if (baseGameFile.exists() && baseGameFile.isFile() && !isAllowedOverride(relativePath)) {
                        conflicts.add([
                            custom: customFile.absolutePath,
                            baseGame: baseGameFile.absolutePath,
                            relativePath: relativePath
                        ])
                    }
                }
            }
        }
        
        if (conflicts) {
            def report = new StringBuilder()
            report.append("\n❌ ASSET CONFLICT ERROR: Custom assets are overwriting core game files!\n\n")
            report.append("The following files in plugins/*/assets/ conflict with data/assets/:\n\n")
            conflicts.each { conflict ->
                report.append("  ❌ ${conflict.relativePath}\n")
                report.append("     Custom:   ${conflict.custom}\n")
                report.append("     BaseGame: ${conflict.baseGame}\n\n")
            }
            report.append("SOLUTION: Move conflicting files to use a custom namespace (e.g., Vex/ instead of Common/)\n")
            report.append("See .github/instructions/ui.instructions.md for naming guidelines.\n")
            
            throw new GradleException(report.toString())
        } else {
            logger.lifecycle("✅ Asset validation passed - no conflicts with core game files")
        }
    }
}

tasks.register("assetsZip", Zip) {
    group = "build"
    description = "Zip plugins/roguelike/assets/ into dist/assets.zip with flattened root"
    dependsOn "ensureDirectories", "processAssetsManifest", "validateAssetConflicts"
    archiveBaseName.set(project(":plugins:roguelike").tasks.named("jar").get().archiveBaseName.get())
    archiveVersion.set(project(":plugins:roguelike").version)
    archiveExtension.set("zip")
    destinationDirectory.set(distDir)
    zip64 = true
    
    // Include processed manifest
    from("$buildDir/processed-assets") {
        include "manifest.json"
        into("")
    }
    
    // Include all other assets except the original manifest
    from(userAssetsDir) {
        into("")
        exclude "manifest.json"
        exclude "Common/UI/Custom/Common.ui"
        exclude "Common/UI/Custom/Common/**"
        exclude "Common/UI/Custom/Pages/**"
        exclude "**/*~"
        eachFile { FileCopyDetails details ->
            // Exclude .gitkeep files (and their parent directories if empty)
            if (details.name == ".gitkeep") {
                details.exclude()
            }
        }
    }

    // Duplicate Vex Custom UI under Custom/ root for client lookup fallback
    from(userAssetsDir) {
        include "Common/UI/Custom/Vex/**"
        include "Common/UI/Custom/Hud/**"
        eachFile { FileCopyDetails details ->
            details.path = details.path.replaceFirst('^Common/UI/Custom/', 'Custom/')
        }
        includeEmptyDirs = false
    }
    doFirst {
        distDir.mkdirs()
    }
}

tasks.register("friendsAssetsZip", Zip) {
    group = "build"
    description = "Zip plugins/friends/assets/ into dist/Friends-<version>.zip"
    dependsOn "ensureDirectories", "processFriendsAssetsManifest", "validateAssetConflicts"
    archiveBaseName.set(project(":plugins:friends").tasks.named("jar").get().archiveBaseName.get())
    archiveVersion.set(project(":plugins:friends").version)
    archiveExtension.set("zip")
    destinationDirectory.set(distDir)
    zip64 = true

    from("$buildDir/processed-friends-assets") {
        include "manifest.json"
        into("")
    }

    from(friendsAssetsDir) {
        into("")
        exclude "manifest.json"
        exclude "**/*~"
        eachFile { FileCopyDetails details ->
            if (details.name == ".gitkeep") {
                details.exclude()
            }
        }
    }

    from(friendsAssetsDir) {
        include "Common/UI/Custom/Friends/**"
        eachFile { FileCopyDetails details ->
            details.path = details.path.replaceFirst('^Common/UI/Custom/', 'Custom/')
        }
        includeEmptyDirs = false
    }

    doFirst {
        distDir.mkdirs()
    }
}

tasks.register("exportPermissions") {
    group = "build"
    description = "Export plugin permissions to static/permissions.json"
    doLast {
        def outputFile = file("static/permissions.json")
        outputFile.parentFile.mkdirs()

        def permissions = []
        def pluginProjects = subprojects.findAll { it.path.startsWith(":plugins:") }
        pluginProjects.each { projectRef ->
            def pluginProps = projectRef.file("src/main/resources/plugin.properties")
            def pluginName = projectRef.name
            if (pluginProps.exists()) {
                pluginProps.readLines().each { line ->
                    if (line.startsWith("plugin-name=")) {
                        pluginName = line.substring("plugin-name=".length()).trim()
                    }
                }
            }

            def javaDir = projectRef.file("src/main/java")
            if (!javaDir.exists()) {
                return
            }

            projectRef.fileTree(javaDir).matching { include "**/*.java" }.each { javaFile ->
                def text = javaFile.getText("UTF-8")
                def permMatcher = (text =~ /PERMISSION_([A-Z0-9_]+)\s*=\s*\"([^\"]+)\"/)
                if (!permMatcher.find()) {
                    return
                }
                permMatcher.reset()
                def descMatcher = (text =~ /super\\(\"[^\"]+\"\\s*,\\s*\"([^\"]+)\"\\)/)
                def baseDesc = descMatcher.find() ? descMatcher.group(1) : null

                def permList = []
                permMatcher.each { match ->
                    permList << [name: match[1], value: match[2]]
                }

                permList.each { perm ->
                    def desc = baseDesc ?: "Permission required"
                    if (permList.size() > 1 && baseDesc != null) {
                        def suffix = perm.name.toLowerCase().replaceAll("_", " ")
                        desc = "${baseDesc} (${suffix})"
                    }
                    permissions << [
                        plugin      : pluginName,
                        permission  : perm.value,
                        description : desc
                    ]
                }
            }
        }

        def json = groovy.json.JsonOutput.prettyPrint(groovy.json.JsonOutput.toJson(permissions))
        outputFile.text = json + System.lineSeparator()
        logger.lifecycle("Wrote permissions to ${outputFile}")
    }
}

tasks.named("build") {
    dependsOn "exportPermissions"
}

tasks.register("copyPluginJarToDist", Copy) {
    group = "build"
    description = "Copy plugin jar into dist"
    dependsOn ":plugins:roguelike:jar"
    from { project(":plugins:roguelike").tasks.named("jar").flatMap { it.archiveFile } }
    into(distDir)
    doFirst {
        distDir.mkdirs()
    }
}

def pluginProjects = subprojects.findAll { it.path.startsWith(":plugins:") }

tasks.register("copyAllPluginJarsToDist", Copy) {
    group = "build"
    description = "Copy all plugin jars into dist"
    dependsOn(pluginProjects.collect { it.tasks.named("jar") })
    pluginProjects.each { projectRef ->
        from(projectRef.tasks.named("jar").flatMap { it.archiveFile })
    }
    into(distDir)
    doFirst {
        distDir.mkdirs()
    }
}

tasks.register("copyEngineJarToDist") {
    group = "build"
    description = "Copy engine jar into dist (legacy wrapper)"
    dependsOn "copyAllPluginJarsToDist"
}

// ============================================================================
// Distribution Tasks
// Tasks for installing built artifacts to server mods directory
// ============================================================================

tasks.register("installToServerMods") {
    group = "distribution"
    description = "Copy jar and assets.zip into data/server/Server/mods"
    dependsOn "ensureModsDir", "assetsZip", "friendsAssetsZip", "copyAllPluginJarsToDist"
    doFirst {
        def assetsZipName = tasks.named("assetsZip").get().archiveFileName.get()
        def friendsZipName = tasks.named("friendsAssetsZip").get().archiveFileName.get()
        def pluginJarNames = pluginProjects.collect { projectRef ->
            projectRef.tasks.named("jar").get().archiveFileName.get()
        }
        delete {
            delete fileTree(modsDir) {
                include assetsZipName
                include friendsZipName
                pluginJarNames.each { include it }
            }
        }
    }
    doLast {
        copy {
            pluginProjects.each { projectRef ->
                from(projectRef.tasks.named("jar").flatMap { it.archiveFile })
            }
            from(tasks.named("assetsZip").flatMap { it.archiveFile })
            from(tasks.named("friendsAssetsZip").flatMap { it.archiveFile })
            into(modsDir)
            duplicatesStrategy = DuplicatesStrategy.INCLUDE
        }
    }
}

// ============================================================================
// Utility Tasks
// ============================================================================

tasks.register("unpackJar") {
    group = "setup"
    description = "Unpack data/server/Server/HytaleServer.jar into data/unpacked"
    dependsOn "ensureDirectories", "ensureServerJar"
    onlyIf { !unpackedDir.exists() || unpackedDir.listFiles()?.length == 0 }
    doLast {
        if (unpackedDir.exists()) {
            unpackedDir.deleteDir()
        }
        copy {
            from(zipTree(serverJar))
            into(unpackedDir)
        }
        logger.lifecycle("Unpacked ${serverJar} into ${unpackedDir}")
    }
}

// ============================================================================
// Application Lifecycle Tasks
// Tasks for running and managing the Hytale server via Docker
// ============================================================================

tasks.register("composeDown") {
    group = "application"
    description = "Stop docker compose stack if running"
    doLast {
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        def psOutput = new ByteArrayOutputStream()
        def psResult = runCommand(["docker", "compose", "-f", composeFile.absolutePath, "ps", "-q"], true, null, true)
        psOutput.write(psResult.output.getBytes())
        if (psResult.output.toString().trim()) {
            logger.lifecycle("Stopping existing compose stack before rebuild...")
            runCommand(["docker", "compose", "-f", composeFile.absolutePath, "down"])
        } else {
            logger.lifecycle("No running compose stack detected; nothing to stop.")
        }
    }
}

tasks.register("start") {
    group = "application"
    description = "Run build then start docker compose in foreground"
    dependsOn "composeDown", "build"
    doLast {
        if (!composeFile.exists()) {
            throw new IllegalStateException("Missing compose file at ${composeFile}")
        }
        logger.lifecycle("Starting docker compose in foreground (logs attached)...")
        runCommand(["docker", "compose", "-f", composeFile.absolutePath, "up"])
    }
}

// ============================================================================
// Gradle Lifecycle Customization
// Modify standard Gradle build lifecycle tasks
// ============================================================================

tasks.register("validateUi", JavaExec) {
    group = "validation"
    description = "Validate UI syntax in all .ui files in plugins/"
    classpath = project(":tools:ui-validator").sourceSets.main.runtimeClasspath
    mainClass = "MBRound18.hytale.tools.UiValidator"
    args file("plugins").absolutePath,
        "--import-root", file("plugins").absolutePath,
        "--import-root", file("data/assets").absolutePath,
        "--asset-root", file("plugins").absolutePath,
        "--asset-root", file("data/assets").absolutePath
    
    dependsOn ":tools:ui-validator:classes"
}

tasks.register("test") {
    group = "validation"
    description = "Run all validation tasks"
    dependsOn "validateUi", ":tools:ui-validator:test"
}

tasks.named("assemble") {
    dependsOn "copyPluginJarToDist", "assetsZip", "validateUi"
}

tasks.named("build") {
    dependsOn "installToServerMods"
    mustRunAfter "composeDown"
}

// ============================================================================
// Error Reporting Hook
// Provide helpful error context on build failure
// ============================================================================
